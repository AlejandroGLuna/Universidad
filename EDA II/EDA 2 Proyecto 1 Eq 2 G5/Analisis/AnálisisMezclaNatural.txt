Análisis Mezcla Natural:
El programa se divide en 4 métodos: partición, mergeAscendente, mergeDescendente y ordenarPorMezclaNatural.
El método partición recibe como parámetro un booleano, éste nos indicará si vamos a ordenar de forma descendente o ascendente. 
El método pretende dividir a un archivo en dos archivos auxiliares que contendrán los bloques que ya se encuentran ordenados y regresa un valor booleano el cual indicará si el archivo auxiliar 2 tiene elementos. 
La forma en que se hace lo anterior es muy sencilla, primeramente declaramos un objeto de la clase Scanner, éste lo usaremos para leer el archivo a ordenar, sin embargo, para poder leer los números del archivo tenemos que definir un delimitador que en nuestro caso será la coma. Seguido a esto declaramos los BufferedWriter de los dos archivos auxiliares que usaremos. A continuación leeremos el primer número del archivo a ordenar y lo escribiremos en el archivo auxiliar 1, inicializamos una variable booleana(band) en true y en una variable auxiliar(aux) de tipo float guardamos el primer número que escribimos. En caso de que el orden sea ascendente entonces mientras el archivo a ordenar tenga elementos recuperaremos su siguiente elemento en una variable float(r). Si r es mayor o igual que aux procederemos a actualizar el valor de aux a r y si band es true escribimos en auxiliar 1 de lo contrario escribiremos en el auxiliar 2; si r no es mayor o igual que aux entonces actualizamos el valor de aux a r y si band es true escribimos en el auxiliar 2 y cambiaremos el valor de band a falso, de ésta forma cuando el ciclo while vuelva a empezar como band es igual a falso entonces escribiremos en el auxiliar 2 en caso de que r sea mayor o igual que aux; si band es falso entonces escribiremos en el auxiliar 1 y cambiaremos el valor de band a verdadero. En caso de que el orden sea descendente se hace exactamente lo mismo, únicamente cambiamos la condición de que r sea mayor o igual que aux a que r sea menor o igual que aux.
Para finalizar cerramos el flujo de datos entre nuestro programa y los archivos y por medio de otro Scanner para lectura del auxiliar 2 determinamos si tiene elementos, en caso de que no tenga retornamos falso en caso contrario retornamos verdadero.

El método mergeAscendente no recibe parámetros ni regresa algún valor, éste únicamente hará la mezcla de los bloques ordenados de los archivos auxiliares y el resultado lo escribirá en el archivo auxiliar a ordenar, es decir, el original. Para lograrlo creamos los Scanner para lectura del auxiliar 1 y 2, borramos el contenido del archivo original y declaramos un bufferedWriter para poder escribir en él. Si los dos archivos tienen elementos entonces leemos el primero de cada uno y encontramos el de menor valor, asignamos su valor a una variable aux, lo escribimos en el archivo original a band le asignamos true y la variable en donde almacenamos ese valor (r1 o r2) la igualamos a cero. Mientras alguno de los auxiliares tenga elementos entonces si band es true y auxiliar 1 tiene elementos leeremos el siguiente número y lo guardaremos en r1; si aux 1 ya no tiene elementos entonces verificamos que r1 o r2 no tengan elementos que aún no han sido escritos, es decir, que su valor sea diferente de cero, en caso de que sí escribimos el elemento y posterior a esto escribimos todos los números que haya en al archivo auxiliar 2. Si band es false entonces hacemos lo mismo pero con el auxiliar 2.
Si r1 es menor que r2 entonces entramos en un if-else anidado en donde evaluamos que r1 sea mayor o igual que aux, ésto indicará que efectivamente estamos colocando los números del menor al mayor, actualizamos el valor de aux a r1, escribimos el número en el original, a band le asignamos true para leer otro número del auxiliar 1 y a r1 le asignamos 0; en caso de que no se cumpla la condición entonces evaluamos que r2 sea mayor o igual que aux para poder escribirlo en el original, actualizar el valor de aux a r2, band ponerlo en false para leer otro número del auxiliar 2 y a r2 le asignamos cero; en caso de que las dos condiciones anteriores no se cumplan entonces actualizamos el valor de aux a r1 lo escribimos en el original, a band le asignamos true y r1 le asignamos cero. En caso de que r1 no sea menor que r2 entonces entramos a otro if-else anidado con las mismas condiciones que el anterior pero cambiando los r1 por r2. Al final verificamos que no hayan quedado números en r1 y r2 sin escribir, es decir, que sus valores sean diferentes de cero, en caso de que si entonces los esribímos hasta el final. Al final del método borramos el contenido de los auxiliares 1 y 2.
	En pocas palabras lo que se hace es leer dos números de los auxiliares, tomamos el menor de ellos y lo escribimos en el archivo
original, leemos otro número del auxiliar del que resultó el menor y lo comparamos con el número que leímos con anterioridad del auxiliar 2, nuevamente escribimos el de menor valor y así sucesivamente hasta acabar con un bloque y continuamos con los demás.
	
El método mergeDescendente hace casi lo mismo que mergeAscendente, únicamente cambiamos las condiciones que hay entre r1, r2 y aux para que consgia mezclar los números y ordenarlos de forma descendente.

En el método ordenarPorMezclaNatural repetimos particion y el merge para el caso de ordenamiento que nos encontremos(ascendente o descente) hasta que el archivo auxiliar 2 ya no tenga elementos, esto indicará que el archivo original ya está ordenado. Para hacer esto usamos un ciclo while que se repetirá hasta que particion arroje false, mientras sea true haremos el merge correspondiente.
